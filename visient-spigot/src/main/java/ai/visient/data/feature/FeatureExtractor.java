package ai.visient.data.feature;

import java.util.*;

public class FeatureExtractor {

    public static Map<String, Double> extractFeatures(Map<String, List<Double>> rawWindow) {
        Map<String, Double> features = new HashMap<>();

        for (Map.Entry<String, List<Double>> entry : rawWindow.entrySet()) {
            String signal = entry.getKey();
            List<Double> values = entry.getValue();

            features.put(signal + "_mean", mean(values));
            features.put(signal + "_std", std(values));
            features.put(signal + "_min", min(values));
            features.put(signal + "_max", max(values));
            features.put(signal + "_range", max(values) - min(values));
            features.put(signal + "_percentile25", percentile(values, 0.25));
            features.put(signal + "_percentile75", percentile(values, 0.75));
            features.put(signal + "_skewness", skewness(values));
            features.put(signal + "_autocorr1", autocorr(values, 1));
            features.put(signal + "_slope", linearSlope(values));
        }

        return features;
    }

    // TODO: Methods generated by LLM. May not be functional.
    private static double mean(List<Double> values) {
        double sum = 0.0;
        for (double v : values) sum += v;
        return sum / values.size();
    }

    private static double std(List<Double> values) {
        double m = mean(values);
        double sumSq = 0.0;
        for (double v : values) sumSq += (v - m) * (v - m);
        return Math.sqrt(sumSq / values.size());
    }

    private static double min(List<Double> values) {
        double min = Double.MAX_VALUE;
        for (double v : values) {
            if (v < min) min = v;
        }
        return min;
    }

    private static double max(List<Double> values) {
        double max = -Double.MAX_VALUE;
        for (double v : values) {
            if (v > max) max = v;
        }
        return max;
    }

    private static double percentile(List<Double> values, double p) {
        values.sort(null);
        int idx = (int) Math.floor(p * (values.size() - 1));
        return values.get(idx);
    }

    private static double skewness(List<Double> values) {
        double m = mean(values);
        double s = std(values);
        double sum = 0.0;
        for (double v : values) {
            sum += Math.pow((v - m) / s, 3);
        }
        return sum / values.size();
    }

    private static double autocorr(List<Double> values, int lag) {
        if (values.size() <= lag) return 0.0;

        double mean = mean(values);
        double num = 0.0;
        double denom = 0.0;

        for (int i = 0; i < values.size() - lag; i++) {
            num += (values.get(i) - mean) * (values.get(i + lag) - mean);
        }
        for (double v : values) {
            denom += Math.pow(v - mean, 2);
        }

        return denom == 0.0 ? 0.0 : num / denom;
    }

    private static double linearSlope(List<Double> values) {
        int n = values.size();
        double sumX = 0.0;
        double sumY = 0.0;
        double sumXY = 0.0;
        double sumXX = 0.0;

        for (int i = 0; i < n; i++) {
            sumX += i;
            sumY += values.get(i);
            sumXY += i * values.get(i);
            sumXX += i * i;
        }

        double numerator = n * sumXY - sumX * sumY;
        double denominator = n * sumXX - sumX * sumX;

        return denominator == 0.0 ? 0.0 : numerator / denominator;
    }
}
